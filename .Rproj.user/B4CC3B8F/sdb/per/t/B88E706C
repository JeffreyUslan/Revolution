{
    "contents" : "# https://github.com/RevolutionAnalytics/rmr2/blob/master/docs/tutorial.md\nlibrary(rmr2)\nrmr.options(backend=\"local\")\n\n##Squaring\n#normal\nsmall.ints = 1:1000\ncbind(small.ints,sapply(small.ints, function(x) x^2))\n\n#mapreduce\nsmall.ints = to.dfs(1:1000)\nfrom.dfs(\n  mapreduce(\n  input = small.ints, \n  map = function(k, v) cbind(v, v^2)\n  )\n)\n\n\n\n##Length Counting\n# send groups ID (randomly generated from a binomial) to Hadoop filesystem\ngroups = rbinom(32, n = 15, prob = 0.4)\nt=tapply(groups, groups, length)\n\n\ngroups = to.dfs(groups)\n# run a mapreduce job\n## map: key value is the group id, value is 1\n## reduce: count the number of observations in each group\n## then, retrieve it from Hadoop filesystem\noutput = from.dfs(\n                  mapreduce(input = groups, \n                            map = function(., v) \n                                keyval(v, 1), \n                            reduce = function(k, vv)  \n                                keyval(k, length(vv))\n                   )\n                  )\n# print results\n## keys: group IDs\n## values: results of reduce job (<em>i.e.</em>, frequency)\nt(data.frame(key=output$key,val=output$val))\nt\n\n#broken ##Word Count\n\n\nromeo_and_juliet=readLines(\"./romeo_and_juliet.txt\",skipNul = TRUE)\nromeo_and_juliet=as.character(sapply(romeo_and_juliet,function(x) x=iconv(x, \"latin1\", \"ASCII\", sub=\"\")))\nromeo_and_juliet=as.character(sapply(romeo_and_juliet,function(x) x=gsub(\"[^[:alpha:] ]\", \"\",x)[[1]]))\nromeo_and_juliet=as.character(sapply(romeo_and_juliet,tolower))\n\n\n\n\n\n\n#function that encapsulates the job\n#     Maps what a word is\n    wc.map =  function(k, lines) {\n        words.list=strsplit(x = lines,split = \" \")\n        words=unlist(words.list)\n        keyval(words, 1)}\n#The reducing function to count the words\n    wc.reduce = function(words, counts ) {\n        keyval(words, sum(counts))}\n# combine the map function and the reduce function\n wordcount=function(input,output=NULL){\n    mapreduce(\n      input = input,\n      output = output,\n\n      map = wc.map,\n      reduce = wc.reduce,\n      combine = TRUE)\n    #       input.format = \"text\",\n}\n\n\noutcome=from.dfs(wordcount(to.dfs(keyval(NULL,romeo_and_juliet))))\nt=data.frame(key=outcome$key,val=as.numeric(outcome$val))\nt[,1]=as.character(t[,1])\nlengths=sapply(t[,1],nchar)\nt=t[which(lengths>4),]\nord=order(t$val,decreasing=TRUE)\nt[ord,][1:50,]\n\n##Linear Least Squares\n\nsolve(t(X)%*%X, t(X)%*%y)\n\nX = matrix(rnorm(2000), ncol = 10)\nX.index = to.dfs(cbind(1:nrow(X), X))\ny = as.matrix(rnorm(200))\n\n\nSum = \n  function(., YY) \n    keyval(1, list(Reduce('+', YY)))\n\n\nXtX = \n  values(\n    from.dfs(\n      mapreduce(\n        input = X.index,\n        map = \n          function(., Xi) {\n            yi = y[Xi[,1],]\n            Xi = Xi[,-1]\n            keyval(1, list(t(Xi) %*% Xi))},\n        reduce = Sum,\n        combine = TRUE)))[[1]]\n\nXty = \n  values(\n    from.dfs(\n      mapreduce(\n        input = X.index,\n        map = function(., Xi) {\n          yi = y[Xi[,1],]\n          Xi = Xi[,-1]\n          keyval(1, list(t(Xi) %*% yi))},\n        reduce = Sum,\n        combine = TRUE)))[[1]]\n\nsolve(XtX, Xty)\n\n\n\n",
    "created" : 1433524653290.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3023215792",
    "id" : "B88E706C",
    "lastKnownWriteTime" : 1433793429,
    "path" : "~/Revolution/rmr_examples.R",
    "project_path" : "rmr_examples.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}